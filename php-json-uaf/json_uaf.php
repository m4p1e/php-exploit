<?php
class X implements JsonSerializable {
    public $prop = "value";
    public function jsonSerialize() {
        global $arr;
        unset($arr[0]);
        var_dump($this); /*trigger uaf*/
        return $this;
    }
}

$arr = [new X()];
var_dump(json_encode([&$arr]));


/*
we should know how is json_encode working? the most important func is below:

	php_json_encode_zval:
	
	switch(Z_TYPE_P(val))		
again:
		//...;

		case IS_OBJECT:
			if(instanceof(val.value.obj,php_json_serializable_ce){
				invoke the jsonSerialize method;
			}	
			
			//fallthrough, do for object same like array.

		case IS_ARRAY:
			foreach zend_array then call php_json_encode_zval;
		
		case IS_REFERENCE:
			take zval from val.value.ref.val;
			goto again;		

		//...;

the important:
there is no speical action for refcount of any type variable;
but if u invoke the jsonSerialize method, it can be execute code and motify some php variable.

so when doing the unset($arr[0]) , the array $arr refcount is 1 and also the object instance $arr[0] refcount is 1 , so u can free it indeed.


let us see the fix for it , still in the function php_json_encode_zval;

	case IS_ARRAY:

	  // it can be described simply as	
	  + add refcount of val.value.arr
	  //...


why it can fix this issue? cuz now when u unset($arr[0]), the array $arr refcount is 2, so it need be separated first , then does unset , so the object instance $arr[0] refcount will be safe. 

http://git.php.net/?p=php-src.git;a=blobdiff;f=ext/json/json_encoder.c;h=41632917158c107294c1e7a8d67d5419ffaa5cf7;hp=8e3eecc0d82bc0b49137a3d25cf3d9b930f76ae2;hb=4831e150c5ada631c1480098b8a42cbf024d8899;hpb=ce73841cdcfd86a2cf5d7e1c251095254985324d
*/