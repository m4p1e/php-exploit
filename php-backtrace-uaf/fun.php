<?php
class Vuln {
    public $a;
    public function __destruct() {
        global $backtrace;
        //unset($this->a);
        $backtrace = (new Exception)->getTrace(); // backtrace has ref to $arg
        //var_dump($backtrace);
    }
}
function trigger_uaf($arg) {
    $arg = str_shuffle(str_repeat('A', 79)); // string to be UAFed
    $vuln = new Vuln();
    $vuln->a = $arg;
}
trigger_uaf('x');
var_dump($backtrace); // access UAF string
//0x7ffff7a950a0
//$16 = (zend_string *) 0x7ffff7a950a0
//trigger_uaf返回时
//$arg所指向的str_ref==2($vule->a)
//return 需要释放局部变量：
// free ($arg); str_ref -- 
// free ($vulr) ->  __destruct -> unset($this->a) str_ref-- => 0 -> real_free(str)
// backtrace => current_execute_data => __destruct_scope =>  prev_execute_data => (triggert_uaf_scope) => debug_backtrace_get_args => saved str


//bug fixed:
//在释放局部变量之前把 EG(current_execute_data)  =  EX(prev_execute_data)
//backtrace => current_execute_data => __destruct_scope  prev_execute_data => (main) => cancel
//与直觉不符的修复，但是对于在return时候的抛exception，也只有魔术方法可以做到了，但是我还是打印的出来的结果可能不符合直觉。

//http://git.php.net/?p=php-src.git;a=commitdiff;h=ef1e4891b47949c8dc0f9482eef9454a0ecdfa1d;hp=8226e704e4e6066a5bd41b57b2934a3371896be2