/* pwnlib extension for PHP */

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif

#include "php.h"
#include "ext/standard/info.h"
#include "zend_exceptions.h"

#include "php_pwnlib.h"

/* For compatibility with older PHP versions */
#ifndef ZEND_PARSE_PARAMETERS_NONE
#define ZEND_PARSE_PARAMETERS_NONE() \
    ZEND_PARSE_PARAMETERS_START(0, 0) \
    ZEND_PARSE_PARAMETERS_END()
#endif

PHP_FUNCTION(pwnlib_remote) {
    unsigned char *str;
    size_t str_len;
    zend_long lval;

    if (zend_parse_parameters(ZEND_NUM_ARGS(), "sL", &str, &str_len, &lval) == FAILURE) {
        php_printf("Failed to parse the parameters\n");
        RETURN_NULL();
    }
    if (lval <= 1024 || lval >= 65536) {
        php_printf("Wrong port!\n");
        RETURN_NULL();
    }
    php_printf("Not implemented yet :P\n");
    RETURN_NULL();
}


PHP_FUNCTION(pwnlib_flat)
{
    zval *arr;

    if (zend_parse_parameters(ZEND_NUM_ARGS(), "a", &arr) == FAILURE) {
        php_printf("Failed to parse the parameters\n");
        RETURN_NULL();
    }

    HashTable *ht = Z_ARR_P(arr);

    uint32_t n = zend_hash_num_elements(ht);

    if (n <= 1) {
        php_printf("Too few elements\n");
        RETURN_NULL();
    }

    if (n*8 > 1024) {
        zend_error(E_ERROR, "Too many elements! This extension cannot handle!\n");
    }

    if (HT_IS_PACKED(ht)) {
        zval *val;
        zend_ulong idx;
        ZEND_HASH_FOREACH_NUM_KEY_VAL(ht, idx, val) {
            if (Z_TYPE_P(val) != IS_LONG) {
                php_printf("Wrong element type\n");
                RETURN_NULL();
            }
            zend_long lval = Z_LVAL_P(val);
            char buf[8] = {};
            int i = 0;
            buf[i++] = (lval)     & 0xff;
            buf[i++] = (lval>>8)  & 0xff;
            buf[i++] = (lval>>16) & 0xff;
            buf[i++] = (lval>>24) & 0xff;
            buf[i++] = (lval>>32) & 0xff;
            buf[i++] = (lval>>40) & 0xff;
            buf[i++] = (lval>>48) & 0xff;
            buf[i++] = (lval>>56) & 0xff;
            zval tmp;
            ZVAL_NEW_STR(&tmp, zend_string_init(buf, 8, 0));
            zend_hash_index_update(ht, idx, &tmp);
        } ZEND_HASH_FOREACH_END();

        RETURN_ARR(ht); // vul2: refcount
    } else {
        php_printf("Wrong type\n");
        RETURN_NULL();
    }
}

PHP_FUNCTION(pwnlib_p32)
{
    zend_long lval;
    char buf[4] = {};

    if (zend_parse_parameters(ZEND_NUM_ARGS(), "L", &lval) == FAILURE) {
        php_printf("Failed to parse the parameters\n");
        RETURN_NULL();
    }
    int i = 0;
    for (; i < 4; ++i) {
        buf[i] = (lval>>(i*8))& 0xff;
    }

    zend_string *retval = zend_string_init(buf, 4, 0);

    RETURN_STR(retval);
}

PHP_FUNCTION(pwnlib_p64)
{
    zend_long lval;
    char buf[8] = {};

    if (zend_parse_parameters(ZEND_NUM_ARGS(), "L", &lval) == FAILURE) {
        php_printf("Failed to parse the parameters\n");
        RETURN_NULL();
    }
    int i = 0;
    for (; i < 8; ++i) {
        buf[i] = (lval>>(i*8))& 0xff;
    }

    zend_string *retval = zend_string_init(buf, 8, 0);

    RETURN_STR(retval);
}

PHP_FUNCTION(pwnlib_u64)
{
    unsigned char *str;
    size_t str_len;

    if (zend_parse_parameters(ZEND_NUM_ARGS(), "s", &str, &str_len) == FAILURE) {
        php_printf("Failed to parse the parameters\n");
        RETURN_NULL();
    }
    if (str_len != 8) {
        php_printf("Invalid parameters");
        RETURN_NULL();
    }

    zend_ulong tmp = 0;
    int i = 0;
    for (; i < 8; ++i) {
        tmp += ((zend_ulong)str[i])<<(i*8);
    }

    zend_long retval = tmp;
    RETURN_LONG(retval);
}

PHP_FUNCTION(pwnlib_u32)
{
    unsigned char *str;
    size_t str_len;

    if (zend_parse_parameters(ZEND_NUM_ARGS(), "s", &str, &str_len) == FAILURE) {
        php_printf("Failed to parse the parameters\n");
        RETURN_NULL();
    }
    if (str_len != 4) {
        php_printf("Invalid parameters");
        RETURN_NULL();
    }

    zend_ulong tmp = 0;
    int i = 0;
    for (; i < 4; ++i) {
        tmp += ((zend_ulong)str[i])<<(i*8);
    }
    zend_long retval = tmp;
    RETURN_LONG(retval);
}

char hextable[16] = {
    '0', '1', '2', '3',
    '4', '5', '6', '7',
    '8', '9', 'a', 'b',
    'c', 'd', 'e', 'f'
};

PHP_FUNCTION(pwnlib_hexdump)
{
    char *str;
    size_t str_len;
    zend_long offset;
    zend_long length;

    if (zend_parse_parameters(ZEND_NUM_ARGS(), "sLL", &str, &str_len, &offset, &length) == FAILURE) {
        php_printf("Failed to parse the parameters\n");
        RETURN_NULL();
    }
    if (offset < 0) {
        php_printf("Invalid parameters");
        RETURN_NULL();
    }
    if (length > 8 || length <= 0) {
        php_printf("Invalid parameters");
        RETURN_NULL();
    }
    char *tmp = (char*)malloc(length * 2);
    if (tmp == NULL) {
        zend_error(E_ERROR, "Memory allocation failed!\n");
    }
    unsigned char *base = str + offset; // vul1: oob read
    int i = 0;
    for (; i < 8; ++i) {
        int hi = (base[i] >> 4) & 0xf;
        int lo = (base[i]) & 0xf;
        tmp[i*2]   = hextable[hi];
        tmp[i*2+1] = hextable[lo];
    }
    zend_string *retval = zend_string_init(tmp, length*2, 0);
    free(tmp);
    RETURN_STR(retval);
}

/* {{{ PHP_RINIT_FUNCTION
 */
PHP_RINIT_FUNCTION(pwnlib)
{
#if defined(ZTS) && defined(COMPILE_DL_PWNLIB)
    ZEND_TSRMLS_CACHE_UPDATE();
#endif
    return SUCCESS;
}
/* }}} */

/* {{{ PHP_MINFO_FUNCTION
 */
PHP_MINFO_FUNCTION(pwnlib)
{
    php_info_print_table_start();
    php_info_print_table_header(2, "pwnlib support", "enabled");
    php_info_print_table_end();
}
/* }}} */

/* {{{ arginfo
 */

ZEND_BEGIN_ARG_INFO(arginfo_pwnlib_flat, 0)
    ZEND_ARG_INFO(0, array)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_pwnlib_p64, 0)
    ZEND_ARG_INFO(0, value)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_pwnlib_u64, 0)
    ZEND_ARG_INFO(0, str)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_pwnlib_p32, 0)
    ZEND_ARG_INFO(0, value)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_pwnlib_u32, 0)
    ZEND_ARG_INFO(0, str)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_pwnlib_hexdump, 0)
    ZEND_ARG_INFO(0, str)
    ZEND_ARG_INFO(0, offset)
    ZEND_ARG_INFO(0, length)
ZEND_END_ARG_INFO()
/* }}} */

/* {{{ pwnlib_functions[]
 */
static const zend_function_entry pwnlib_functions[] = {
    PHP_FE(pwnlib_flat,         arginfo_pwnlib_flat)
    PHP_FE(pwnlib_p64,          arginfo_pwnlib_p64)
    PHP_FE(pwnlib_p32,          arginfo_pwnlib_p32)
    PHP_FE(pwnlib_u64,          arginfo_pwnlib_u64)
    PHP_FE(pwnlib_u32,          arginfo_pwnlib_u32)
    PHP_FE(pwnlib_hexdump,      arginfo_pwnlib_hexdump)
    PHP_FE_END
};
/* }}} */

/* {{{ pwnlib_module_entry
 */
zend_module_entry pwnlib_module_entry = {
    STANDARD_MODULE_HEADER,
    "pwnlib",                    /* Extension name */
    pwnlib_functions,            /* zend_function_entry */
    NULL,                            /* PHP_MINIT - Module initialization */
    NULL,                            /* PHP_MSHUTDOWN - Module shutdown */
    PHP_RINIT(pwnlib),            /* PHP_RINIT - Request initialization */
    NULL,                            /* PHP_RSHUTDOWN - Request shutdown */
    PHP_MINFO(pwnlib),            /* PHP_MINFO - Module info */
    PHP_PWNLIB_VERSION,        /* Version */
    STANDARD_MODULE_PROPERTIES
};
/* }}} */

#ifdef COMPILE_DL_PWNLIB
# ifdef ZTS
ZEND_TSRMLS_CACHE_DEFINE()
# endif
ZEND_GET_MODULE(pwnlib)
#endif